1. Дана функция (статический метод) на языке Java:

static int myfunc(int[] a) {
     int x = 0;
     for (int i = 0; i < a.length; i++) {
         for (int j = i; j < a.length; j++) {
             if (a[j] != a[i]) {
                 if (j - i > x) {
                     x = j - i;
                 }
                 i = j - 1;
                 break;
             }
         }
     }
     return x;
}

Ответы:
	Что делает эта функция?
	Находит максимальное число одинаковых элементов идущих в ряд

	Какая у неё алгоритмическая сложность?
   	O(n^2)

	Есть ли в этой функции логические дефекты? Если да, то какие?
   	Алгоритм не будет учитывать идущие в ряд элементы которые находятся в конце массива (Пример : { 1, 0, 1, 1, 1, 1, 9, 9, 9, 9, 9 })

	Можно ли как-то улучшить данный код? Если да, напишите улучшенный вариант.
   	static int myfunc(int[] a) {
            int x = 1;
            int buff = 1;
            for (int i = 0; i < a.length - 1; i++) {
                if (a[i] == a[i + 1]) {
                    buff++;
                    if (buff > x) {
                        x = buff;
                    }
                }
                else {
                    buff = 1;
                }
            }
            return x;
	}

	Какая алгоритмическая сложность у вашего варианта?
   	O(n)


2. Даны векторы A и B с координатами, соответственно, (x1, y1, z1) и
(x2, y2, z2). Как узнать, перпендикулярны ли они друг другу?

Ответ:
   Для перпендикулярности двух ненулевых векторов формула и формула необходимо и достаточно, чтобы их скалярное произведение равнялось нулю, то есть должно выполняться следующее    равенство
   x1*x2 + y1*y2 + z1*z2 = 0


3. Один поезд выехал из пункта А в пункт Б, одновременно с ним другой
поезд выехал из пункта Б в пункт А. Поезда двигаются с постоянными
скоростями.
Они встретились в 15 часов, машинисты на ходу помахали друг другу из
окон, и продолжили двигаться к своим конечным пунктам.
Первый поезд доехал до своего пункта назначения через 9 часов после
встречи, а второй до своего - через 16 часов после встречи. Во сколько
они стартовали?

Ответ: 
	в 3 часа

	Решение:
	1)что бы найти ответ на вопрос необходимо составить систему уравнений 
	16 * v2 = t * v1
	9 * v1 = t *v2

	2) выделим t (то есть количество времени в пути до встречи)
	t = (16 * v2)/(v1) = (9 * v1)/(v2) 

	3) получим v1
	v1 = (4 * v2) / 3

	4) подставим содержимое вместо v1 и подсчитаем t
	t = (16 * v2) / v1 = (16 * v2 * 3)/ (4*v2) = 12

	5) 
   	15 - t = 15 - 12 = 3



4. Казино предлагает вам сыграть в игру: вы бросаете два 6-гранных
игральных кубика, и получаете приз в зависимости от выпавшей на них
суммы очков:
12 очков: 100 рублей
11 очков: 80 рублей
10 очков: 70 рублей
9 очков: 60 рублей
от 2 до 8 очков: 0 рублей
Сколько вы согласны заплатить за возможность один раз сыграть в такую игру?

Ответ:
	На коротком расстоянии любая теория вероятности не имеет смысла, а точнее нет никаких гарантий возможности выстраивать стратегии победы тем более если есть возможность           сыграть только один раз (следовательно лучше играть только за бесплатно либо вообще не играть)

	На длительном расстоянии что бы выходить в плюс в данном казино следует платить меньше 28 рублей за раз ((100 + 80 + 70 + 60) / 11)


5. Напишите функцию, которая принимает на вход массив, и возвращает
такой же массив, но без тех элементов, которых в исходном массиве было
чётное количество.
Писать можно на любом из популярных высокоуровневых языков программирования.

Оцените алгоритмическую сложность своей реализации.

Ответ:
	Ссылка на репозиторий - https://github.com/Osawerengeka/RemoveAt/blob/master/ConsoleApp5/Program.cs
	алгоритмическая сложность - O(n)


